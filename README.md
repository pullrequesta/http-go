# http-go

http-go is my own implementation of `HTTP/1.1` server directly on top of Go’s standard `TCP` layer.
This library covers all essential parts of `HTTP/1.1` protocol, including parsing the request line and headers, according to [RFC 9110] and [RFC 9112]. It handles the message body, either `Content-Length` or transfer-chunked encoding behaviour. Furthermore, it implements the structured handling system to customize the respective response error type.
The library also supports proxy requests.

> [!WARNING]
> This is not a comprehensive library, e.g. it is not able to parse multi-line headers.

## Project Structure

```zsh
http-go/
 ├── cmd/httpserver/
 │    └── main.go      **Entry point for running the HTTP server**
 │── internal/
 │    ├── headers/     **Creates the gerneric header map for parsing the headers**
 │    ├── request/     **Parses the request, headers, and the message body**
 │    ├── response/    **Writes the response, performing chunked encoding**
 │    └── server/      **Listener, connection loop, handler dispatch**
 └── README.md
```

## :sparkles: Features

### Supported Transport Potocols

- [x] TCP
- [x] UDP

### :books: RFC References

- [RFC 7231] – An active and widely referenced RFC.
- [RFC 9112] – Easier to read than RFC 7231, relies on understanding from RFC 9110.
- [RFC 9110] – Covers HTTP "semantics."
- [RFC 2616] – Deprecated by RFC 7231.

### :wrench: HTTP Stack Components

- Custom request parser using a state machine
- Support for request line, headers, CRLF parsing, and message bodies
- Custom response writer, including:
  - Status line
  - Headers
  - Body
  - Chunked body
- Chunked Transfer-Encoding writer:
  - Writes chunk size as a hexa decimal number
  - Writes data in the form of chunks
  - Writes terminating line
- Proxy Handler
  - Built-in proxy routing for paths like:
    - /httpbin/x → <https://httpbin.org/x>

### :rocket: Getting Started

1. Install Go

```zsh
Ensure Go ≥ 1.20 is installed.
```

2. Run the HTTP server

```zsh
go run cmd/httpserver/main.go
```

3. Make a request by using curl command

```zsh
curl -v localhost:42069
```

4. Raw HTTP over netcat (nc)

```zsh
echo -e "GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n" | nc localhost 42069
```

5. Make a proxy request

```zsh
curl -v localhost:42069/httpbin/stream/10
```

### :outbox_tray: Example HTTP Response

A typical HTTP response looks like:

```http
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 13
 
Hello World!
```

A chunked HTTP response looks like:

```http
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

7
Welcome
1c
to Mozilla Developer Network
0
```

### :mortar_board: Learning Source: Boot.dev HTTP Server Course

This project was built while following the Boot.dev "Build an HTTP Server in Go" course:
[BOOT.DEV](https://www.boot.dev/lessons/22c5b91f-f2c1-4ae8-af44-036a9c6d6794)

> [!NOTE]
> Also this doc is not generated by AI, i like using emojis

[RFC 9110]: (https://datatracker.ietf.org/doc/html/rfc9110)
[RFC 9112]: (https://datatracker.ietf.org/doc/html/rfc9112)
[RFC 7231]: (https://datatracker.ietf.org/doc/html/rfc7231)
[RFC 2616]: (https://datatracker.ietf.org/doc/html/rfc2616)
